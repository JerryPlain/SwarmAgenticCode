# SwarmAgentic 项目逻辑详解

本文档将帮助您逐步理解整个项目的核心逻辑和工作流程。

---

## 📚 目录

1. [项目核心思想](#项目核心思想)
2. [整体架构](#整体架构)
3. [核心概念](#核心概念)
4. [完整工作流程](#完整工作流程)
5. [关键模块详解](#关键模块详解)
6. [代码阅读路径](#代码阅读路径)

---

## 🎯 项目核心思想

### 问题背景
传统多智能体系统需要人工设计：
- 需要人工定义每个智能体的角色
- 需要人工设计智能体之间的协作流程
- 需要大量试错和调优

### 解决方案
**SwarmAgentic** 使用**粒子群优化（PSO）** + **大语言模型（LLM）**来自动生成和优化多智能体系统：

1. **自动生成**：从任务描述自动生成多智能体团队结构
2. **自动优化**：通过PSO算法迭代优化团队性能
3. **自动诊断**：使用LLM分析失败原因并改进

### 类比理解
就像训练一个足球队：
- **初始阶段**：随机组建一支队伍（生成初始团队）
- **训练阶段**：让队伍打比赛，记录表现（执行任务并评估）
- **优化阶段**：分析失败原因，调整战术和人员（PSO优化）
- **迭代过程**：重复训练和优化，直到找到最佳配置

---

## 🏗️ 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                    SwarmAgentic 系统                     │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ┌──────────────┐      ┌──────────────┐                │
│  │   任务描述    │  →   │   PSO优化器   │                │
│  │  (Task Desc) │      │  (pso.py)    │                │
│  └──────────────┘      └──────┬───────┘                │
│                                │                         │
│                                ▼                         │
│  ┌──────────────────────────────────────┐               │
│  │        粒子群 (Particles)            │               │
│  │  ┌──────┐  ┌──────┐  ┌──────┐      │               │
│  │  │粒子1 │  │粒子2 │  │粒子3 │ ...  │               │
│  │  └──┬───┘  └──┬───┘  └──┬───┘      │               │
│  └─────┼─────────┼─────────┼──────────┘               │
│        │         │         │                           │
│        ▼         ▼         ▼                           │
│  ┌──────────────────────────────────────┐             │
│  │        多智能体团队 (Team)             │             │
│  │  ┌──────┐  ┌──────┐  ┌──────┐      │             │
│  │  │角色1 │→ │角色2 │→ │角色3 │      │             │
│  │  └──────┘  └──────┘  └──────┘      │             │
│  └──────────────────────────────────────┘             │
│        │                                                │
│        ▼                                                │
│  ┌──────────────────────────────────────┐             │
│  │      执行工作流 (Workflow Code)        │             │
│  │  def forward(team):                 │             │
│  │      role1_output = team.call(...)  │             │
│  │      role2_output = team.call(...)  │             │
│  │      return final_result            │             │
│  └──────────────────────────────────────┘             │
│        │                                                │
│        ▼                                                │
│  ┌──────────────────────────────────────┐             │
│  │        评估 (Evaluation)              │             │
│  │  - 执行任务                          │             │
│  │  - 计算分数 (Fitness)                │             │
│  │  - 识别问题 (Failure Analysis)       │             │
│  └──────────────────────────────────────┘             │
│        │                                                │
│        ▼                                                │
│  ┌──────────────────────────────────────┐             │
│  │      PSO更新 (Update Particles)       │             │
│  │  - 更新位置 (团队结构)                │             │
│  │  - 更新速度 (改进方向)                │             │
│  └──────────────────────────────────────┘             │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

---

## 🔑 核心概念

### 1. **粒子 (Particle)**
PSO算法中的基本单位，代表一个候选的多智能体系统。

**粒子的组成**：
- **位置 (Position)**：`(team, code)`
  - `team`：多智能体团队（包含角色和工作流）
  - `code`：执行工作流的Python代码
- **速度 (Velocity)**：改进方向和幅度
- **适应度 (Fitness)**：团队在任务上的表现分数
- **历史最佳 (Best Position)**：该粒子历史上表现最好的配置

### 2. **团队 (Team)**
一个多智能体系统，包含：

**角色 (Role)**：
```python
{
    "Name": "问题理解专家",
    "Responsibility": "分析数学问题的关键信息",
    "Policy": "1. 识别问题类型\n2. 提取关键数字\n3. 确定求解步骤"
}
```

**工作流 (Workflow)**：
```python
[
    {"Step": "1", "Role": "问题理解专家", "Input": "", "Output": "问题分析"},
    {"Step": "2", "Role": "解题专家", "Input": "问题分析", "Output": "解题步骤"},
    {"Step": "3", "Role": "答案整合专家", "Input": "解题步骤", "Output": "最终答案"}
]
```

### 3. **工作流代码 (Workflow Code)**
将工作流转换为可执行的Python函数：

```python
def forward(team):
    # Step 1: 问题理解专家分析问题
    analysis = team.call("问题理解专家", inputs=[], output="问题分析结果")
    
    # Step 2: 解题专家基于分析结果解题
    solution = team.call("解题专家", inputs=[analysis], output="详细解题步骤")
    
    # Step 3: 答案整合专家整合最终答案
    final_answer = team.call("答案整合专家", inputs=[solution], output="最终答案")
    
    return final_answer
```

### 4. **PSO优化过程**
- **初始化**：创建多个粒子（不同的团队配置）
- **评估**：每个粒子执行任务，计算适应度
- **更新**：
  - 更新个人最佳位置
  - 更新全局最佳位置
  - 根据最佳位置更新速度和位置
- **迭代**：重复评估和更新，直到收敛

---

## 🔄 完整工作流程

### 阶段1：初始化 (Initialization)

**文件**：`pso.py` → `initialize_particles()`

1. **生成初始团队**
   - 使用LLM根据任务描述生成多智能体团队
   - 调用 `prompt/team_init.py` 中的 `init_team()`
   - LLM返回：角色列表 + 工作流定义

2. **生成工作流代码**
   - 使用LLM将工作流转换为Python代码
   - 调用 `prompt/write_forward.py` 中的 `build_forward()`
   - 生成 `forward(team)` 函数

3. **创建粒子**
   - 为每个温度设置创建一个粒子
   - 每个粒子包含：`(team, code)`

**代码位置**：
```python
# mgsm/pso.py, line 195-222
def initialize_particles(...):
    particles = []
    for i, item in enumerate(settings): 
        team = Team(llm=llm_role, logger=logger)
        team.init(llm=llm)  # 初始化团队
        code = get_forward(...)  # 生成工作流代码
        particle = Particle(position=(team, code), ...)
        particles.append(particle)
    return particles
```

---

### 阶段2：评估 (Evaluation)

**文件**：`pso.py` → `Particle.evaluate()`

1. **执行任务**
   - 对数据集中的每个样本：
     - 调用 `forward(team)` 函数
     - 团队中的角色按工作流顺序执行
     - 每个角色调用LLM生成响应

2. **评估结果**
   - 调用 `eval.py` 中的 `evaluate()`
   - 计算分数（如：答案是否正确）
   - 识别问题（如：答案错误的原因）

3. **记录反馈**
   - 如果分数不完美，记录问题描述
   - 保存执行日志

**代码位置**：
```python
# mgsm/pso.py, line 58-150
async def evaluate(self, dataset, iter, i_pos):
    team = self.position[0]  # 获取团队
    code = self.position[1]  # 获取代码
    func = set_forward(code)  # 将代码字符串转换为函数
    
    # 对每个数据样本执行
    for data in dataset:
        res = func(team)  # 执行工作流
        score, problem = evaluate(llm, res, data['targets'])  # 评估
        # 记录结果...
```

**角色执行过程**：
```python
# role.py, line 234-251
def call(self, required_role: str, inputs: List = [], output: str = ""):
    # 找到对应的角色
    for role in self.roles:
        if role.name == required_role:
            # 角色调用LLM生成响应
            response, log = role(inputs, output)
            return response
```

---

### 阶段3：失败分析 (Failure Analysis)

**文件**：`prompt/failure_identify.py`, `prompt/failure_improve.py`

1. **识别失败原因**
   - 使用LLM分析执行日志和问题描述
   - 找出团队失败的根本原因
   - 例如："角色A的输出格式不正确，导致角色B无法理解"

2. **生成改进建议**
   - 基于失败原因，生成具体的改进方案
   - 例如："修改角色A的输出格式为JSON，并添加字段说明"

**代码位置**：
```python
# mgsm/pso.py, line 150-180
# 收集所有失败案例
failures = [result for result in results if result['score'] < 1]

# 识别失败原因
failure_analysis = identify_failure(llm, failures, ...)

# 生成改进建议
improvements = improve_failure(llm, failure_analysis, ...)
```

---

### 阶段4：PSO更新 (PSO Update)

**文件**：`pso.py` → `update_particles()`

PSO更新包含三个部分：

#### 4.1 更新个人最佳 (Personal Best)
```python
if particle.fitness > particle.best_fitness:
    particle.best_position = particle.position
    particle.best_fitness = particle.fitness
```

#### 4.2 更新全局最佳 (Global Best)
```python
if particle.fitness > global_best_fitness:
    global_best_position = particle.position
    global_best_fitness = particle.fitness
```

#### 4.3 更新速度和位置 (Velocity & Position Update)

**速度初始化**（第一次迭代）：
- 使用LLM分析当前团队和任务
- 生成初始改进方向（速度）

**速度更新**（后续迭代）：
- 考虑三个因素：
  1. **惯性**：保持当前改进方向
  2. **个人最佳**：向自己历史最佳位置移动
  3. **全局最佳**：向全局最佳位置移动

**位置更新**：
- 根据速度更新团队结构
- 使用LLM修改角色的Policy、工作流等

**代码位置**：
```python
# mgsm/pso.py, line 180-230
# 初始化速度
if particle.velocity is None:
    particle.velocity = initialize_velocity(llm, particle, ...)

# 更新速度
particle.velocity = update_velocity(
    llm, 
    particle, 
    global_best_position,
    ...
)

# 更新位置（团队结构）
new_team = update_team(
    llm,
    particle.position[0],  # 当前团队
    particle.velocity,      # 速度（改进方向）
    ...
)
```

---

### 阶段5：迭代优化

重复阶段2-4，直到达到最大迭代次数或收敛。

**主循环**：
```python
# mgsm/pso.py, line 278-350
async def main(max_iteration=5, ...):
    # 初始化粒子
    particles = initialize_particles(...)
    global_best_position = None
    global_best_fitness = 0.0
    
    # 迭代优化
    for iteration in range(max_iteration):
        # 1. 评估所有粒子
        for particle in particles:
            await particle.evaluate(dataset, iteration, i)
        
        # 2. 更新全局最佳
        global_best_position, global_best_fitness = \
            update_global_best(particles, ...)
        
        # 3. 更新粒子（PSO更新）
        for particle in particles:
            update_particles(particle, global_best_position, ...)
        
        # 4. 保存检查点
        save_particles(particles)
```

---

## 📦 关键模块详解

### 1. `role.py` - 角色和团队

**核心类**：
- `Role`：单个智能体角色
  - `name`：角色名称
  - `responsibility`：职责描述
  - `policy`：执行策略
  - `response()`：调用LLM生成响应

- `Team`：多智能体团队
  - `roles`：角色列表
  - `workflow`：工作流定义
  - `call()`：调用指定角色执行任务

**关键方法**：
```python
# 角色响应
def response(self, task_instance, others_outputs, output):
    # 构建提示词
    prompt = ROLE_PROMPT.format(
        name=self.name,
        responsibility=self.responsibility,
        policy=self.policy,
        instance=task_instance,
        information=others_outputs,
        output=output
    )
    # 调用LLM
    response = self.llm.invoke(prompt)
    return response
```

---

### 2. `func.py` - 任务执行

**核心函数**：
- `get_forward()`：使用LLM生成工作流代码
- `set_forward()`：将代码字符串转换为可执行函数
- `get_all_examples()`：加载数据集

**关键代码**：
```python
def set_forward(next_solution):
    """将代码字符串转换为函数"""
    namespace = {}
    exec(next_solution, globals(), namespace)  # 执行代码
    func = namespace['forward']  # 获取forward函数
    return func
```

---

### 3. `eval.py` - 评估

**核心函数**：
- `evaluate()`：评估任务执行结果
- `get_fitness()`：计算适应度（平均分数）

**示例（MGSM任务）**：
```python
def evaluate(llm, response, answer):
    # 从响应中提取最终答案
    extracted = extract_final_answer(llm, response)
    
    # 与正确答案比较
    score = int(extracted) == int(answer)
    
    # 如果有问题，记录问题描述
    problem = "" if score == 1 else f"正确答案是 {answer}"
    
    return score, problem
```

---

### 4. `prompt/` - 提示词模板

**关键文件**：

1. **`team_init.py`**：初始化团队
   - 输入：任务描述
   - 输出：角色列表 + 工作流

2. **`write_forward.py`**：生成工作流代码
   - 输入：团队结构 + 工作流
   - 输出：Python代码字符串

3. **`failure_identify.py`**：识别失败原因
   - 输入：执行日志 + 问题描述
   - 输出：失败原因分析

4. **`team_update.py`**：更新团队结构
   - 输入：当前团队 + 速度（改进方向）
   - 输出：更新后的团队

5. **`velocity_update.py`**：更新速度
   - 输入：当前团队 + 个人最佳 + 全局最佳
   - 输出：新的速度（改进方向）

---

## 🗺️ 代码阅读路径

### 路径1：理解整体流程（推荐新手）

1. **`README.md`** - 了解项目概述
2. **`mgsm/pso.py`** - 主程序入口
   - `main()` 函数：整体流程
   - `Particle` 类：粒子定义
3. **`mgsm/role.py`** - 理解角色和团队
   - `Role` 类：单个角色
   - `Team` 类：多智能体团队
4. **`mgsm/func.py`** - 理解任务执行
   - `set_forward()`：代码执行
   - `get_all_examples()`：数据加载
5. **`mgsm/eval.py`** - 理解评估逻辑

### 路径2：深入理解PSO优化

1. **`mgsm/pso.py`** - PSO主循环
   - `initialize_particles()`：初始化
   - `Particle.evaluate()`：评估
   - `update_particles()`：更新
2. **`mgsm/prompt/team_init.py`** - 团队初始化
3. **`mgsm/prompt/team_update.py`** - 团队更新
4. **`mgsm/prompt/velocity_update.py`** - 速度更新
5. **`mgsm/prompt/failure_identify.py`** - 失败分析

### 路径3：理解特定任务（如MGSM）

1. **`mgsm/prompt/base.py`** - 任务定义
2. **`mgsm/func.py`** - 任务相关函数
   - `get_lang_examples()`：加载MGSM数据
3. **`mgsm/eval.py`** - 任务评估
   - `evaluate()`：MGSM特定的评估逻辑

---

## 💡 关键理解点

### 1. 为什么使用PSO？
- **探索性**：可以同时尝试多个不同的团队配置
- **优化性**：通过迭代逐步改进
- **自适应性**：根据任务自动调整

### 2. 为什么需要工作流代码？
- **灵活性**：可以定义复杂的角色交互
- **可执行性**：将抽象的工作流转换为可运行的程序
- **可优化性**：代码可以被修改和优化

### 3. LLM在哪些地方发挥作用？
1. **团队生成**：根据任务描述生成初始团队
2. **代码生成**：将工作流转换为代码
3. **角色执行**：每个角色调用LLM完成任务
4. **失败分析**：分析失败原因
5. **团队优化**：根据分析结果改进团队

### 4. 如何理解"语言驱动的PSO"？
传统PSO在数值空间中优化，这里在"语言空间"中优化：
- **位置**：不是数值，而是团队结构（用自然语言描述）
- **速度**：不是数值向量，而是改进方向（用自然语言描述）
- **更新**：不是数值运算，而是LLM生成新的团队结构

---

## 🎓 学习建议

1. **先运行一个小例子**（如果有API密钥）
   - 设置 `--max_iteration 1` 和 `--dataset_size 1`
   - 观察执行过程

2. **阅读日志文件**
   - 查看 `results/` 目录下的日志
   - 理解每个步骤的输入输出

3. **修改任务定义**
   - 尝试修改 `prompt/base.py` 中的任务描述
   - 观察生成的团队如何变化

4. **理解一个完整的迭代**
   - 跟踪一个粒子从初始化到更新的完整过程
   - 理解PSO如何改进团队

---

## 📝 总结

SwarmAgentic的核心创新在于：
1. **自动化**：从任务描述自动生成多智能体系统
2. **优化**：使用PSO算法自动优化系统性能
3. **语言驱动**：所有优化都在自然语言空间中进行
4. **端到端**：从任务到最终系统的完整自动化流程

希望这份文档能帮助您理解整个项目！如有疑问，可以查看具体代码文件或阅读论文。
